<html>
<head>
    <title> qiss REPL </title>
    <style>
        body {
        background-color: black;
        font-family: "Monaco", monospace;
        font-size: 10pt;
        height: 100%;
        width: 100%;
        overflow: hidden;
        }
        #editor {
        background-color: black;
        position: absolute;
        top: 5%;
        left: 50%;
        width: 40%;
        height: 90%;
        }
        textarea {
        background-color: black;
        font-smooth: never;
        -webkit-font-smoothing: none;
        font-family: "Monaco", monospace;
        font-size: 10pt;
        width: 100%;
        height: 100%;
        border: none;
        border-left: 1px solid gray;
        -moz-tab-size:4;
        -o-tab-size:4;
        tab-size:4;
        }
        #repl {
        background-color: black;
        position: absolute;
        display: table;
        top: 5%;
        left: 10%;
        width: 80%;
        height: 90%;
        }
        #scroll-w {
        display: table-row;
        height: 100%;
        }
        #scroll-h {
        position: relative;
        padding: 5px;
        overflow-y: scroll;
        background-color: black;
        height: 100%;
        word-wrap: break-word;
        word-break: break-all;
        hyphens: none;
        -moz-box-sizing: border-box;
        }
        #scroll {
        position: absolute;
        color: green;
        bottom: 0px;
        max-height: 100%;
        }
        #prompt {
        display: table-row;
        background-color: black;
        font-family: "Monaco", monospace;
        font-size: 10pt;
        color: green;
        padding: 5px 0px 5px 20px;
        margin: 0;
        border: none;
        bottom: 0px;
        width: 100%;
        height: 30px;
        max-height: 30px;
        overflow: hidden;
        }
        textarea:focus {
        outline: none;
        }
        ::-webkit-scrollbar {
        display: none;
        }
    </style>
</head>

<body>
 <div id="repl">
     <div id="scroll-w">
         <div id="scroll-h">
             <div id="scroll">

             </div>
         </div>
     </div>
     <form>
         <!-- please hide me once the event debugging is done -->
         <input id='go' type='button' value='Go!'/>
     </form>
     <div>
         <textarea id="prompt" autocomplete="off"></textarea>
     </div>
 </div>

 <div id="editor" style="display: none;">
     <textarea id="textedit"></textarea>
 </div>

 <!-- Embedding qiss code directly in an HTML file   dom[`prompt]text str every 2000; -->
 <script type='text/qiss'>
      show`click ev dom`go;            / dom with sym => single element by ID
      / show {str dom`prompt}`keydown ev dom`prompt;
      /  0. trap all keydown events -- (dom`prompt)`value x@&1

      / dom[`result]text str every 2000;

      / dom[`scroll] text str every 2000;  / [`innerHTML]:"heeeeeellllo"; / ,:"hello this is a test";

      / (dom`scroll)[`innerHTML],:
      {show `which of x} `keydown ev dom`prompt;  / event ev element --> NOT `ONkeydown!!
      / show (dom`scroll)[`innerHTML],:(dom`prompt)`value
      /  1. when the above function returns true (user has pressed the <ENTER> key) do:
      /     (dom`scroll)[`innerHTML],:(dom`prompt)`value;  / shove the entry into the upper line
      /  2. send the contents for execution - via eval(?) see line 2066 of qiss.core
      /  3. (dom`prompt)[`value]:""    / clear the prompt
 </script>
 <script src='qiss/qiss.qiss' type='text/qiss'></script>
 <!-- We must load qiss.js at the bottom so that all the qiss
        elements exist when we startup the interpreter -->
 <script src="js/compiled/qiss.js" type="text/javascript"></script>
 <script>


// below is a faithful cut-and-paste job, courtesy of JohnEarnest
//  https://github.com/JohnEarnest/ok
//
// most of the code below can go away in the qiss world, but I made
// a few surgical changes to cut to the goal of
// getting a HTML based qiss REPL up and running - all the changes are marked with 'TODO'
// rest of the code is John's verbatim.
//
document.getElementById("textedit").onkeydown = function(event) {
	if (event.keyCode == 13 && event.shiftKey) {
		saveBuffer();
		if (this.selectionStart == this.selectionEnd) {
			prompt.value = this.value;
		}
		else {
			prompt.value = this.value.substring(this.selectionStart, this.selectionEnd);
		}
		processLine();
		prompt.value = "";
		printRepl("&nbsp;&nbsp");
		return false;
	}
	if (event.keyCode == 9) {
		var text  = this.value;
		var start = this.selectionStart;
		var end   = this.selectionEnd;
		this.value = text.substring(0, start) + '\t' + text.substring(end);
		this.selectionStart = this.selectionEnd = start + 1;
		saveBuffer();
		return false;
	}
	saveBuffer();
};
function saveBuffer() {
	localStorage.setItem("oKeditbuffer", document.getElementById("textedit").value);
}
function loadBuffer() {
	var editbuffer = localStorage.getItem("oKeditbuffer");
	if (!editbuffer) { editbuffer = "/ contents of this editor is automatically saved in local storage."; }
	document.getElementById("textedit").value = editbuffer;
}

// var env = baseEnv();
var env = [];  /// no baseEnv defined  TODO
var entries = [];
var entryIndex = 0;
var showtrace = false;
var partial = "";
var eid = 0;


// setIO("0:", 2, print);              TODO
// setIO("0:", 4, print);              TODO
// setIO("0:", 1, readText);           TODO
// setIO("1:", 1, readJSON);           TODO

var repl = document.getElementById("repl");
var scroll = document.getElementById("scroll");
var panel = document.getElementById("scroll-h");
var prompt = document.getElementById("prompt");

prompt.focus();
//
//  this is where each command line input goes to qiss parser
//  redirecting to qiss event handler
//
// prompt.onkeydown = processInput;      TODO
//
scroll.innerHTML =
	"Welcome to <a href='https://github.com/natemc/qiss' target='_blank'>qiss</a>"+
	"<br>&nbsp;&nbsp;";

function escapeHTML(text) {
	text += "";
	text = text.replace(/&/g, "&amp;");
	text = text.replace(/</g, "&lt;");
	text = text.replace(/>/g, "&gt;");
	text = text.replace(/ /g, "&nbsp;");
	text = text.replace(/\r/g, "<font color='gray'>&rarr;</font>");
	text = text.replace(/\n/g, "<br>");
	return text;
}

function toggle(id) {
	e = document.getElementById(id);
	e.style.display = e.style.display == "none" ? "inline" : "none";
}

function rectadd(a, b) {
	b = b.split("\n");
	// pad heights vertically to match
	while(a.length < b.length) { a.unshift(""); }
	while(b.length < a.length) { b.unshift(""); }
	// pad a width to rectangularize and concat
	var aw = 0;
	for(var z=0;z<a.length;z++) { aw = Math.max(aw, a[z].length); }
	for(var z=0;z<a.length;z++) { while(a[z].length < aw) { a[z] += " "; } a[z] += b[z]; }
	return a;
}

// TODO
//
//setTrace(function(verb, a, v, b, env, value) {
//	if (showtrace) {
//		var r = [""];
//		r = rectadd(r, (a ? format(a) : ""));
//		if (a) { r = rectadd(r, " "); }
//		r = rectadd(r, (v ? format(v) : ""));
//		r = rectadd(r, verb + " ");
//		r = rectadd(r, (b ? format(b) : ""));
//		r = rectadd(r, " \r ");
//		r = rectadd(r, format(value));
//		printRepl(escapeHTML(r.join("\n")));
//		printRepl("");
//	}
//	return value;
//});

function processInput(e) {
	if (e.keyCode == 38) {
		if (entries.length == 0) { return false; }
		if (entryIndex > 0) {
			entryIndex--;
			prompt.value = entries[entryIndex];
		}
		return false;
	}
	if (e.keyCode == 40) {
		if (entries.length == 0 || entryIndex >= entries.length-1) {
			entryIndex = entries.length;
			prompt.value = "";
			return false;
		}
		entryIndex++;
		prompt.value = entries[entryIndex];
		return false;
	}
	if (e.keyCode != 13) { return; }
	printReplBare("<font color='gray'>"+escapeHTML(prompt.value)+"</font>");
	if (prompt.value != "") { processLine(); }
	if (prompt.value != "") { entries.push(prompt.value); }
	entryIndex = entries.length;
	prompt.value = "";
	printRepl(partial == "" ? "&nbsp;&nbsp" : "&gt;&nbsp;");
	return false;
}

function printEnv(filter, label) {
	var found = {};
	var len = 0;
	for(var key in env.d) {
		if (!filter(env.d[key])) { continue; }
		len = Math.max(key.length, len);
		found[key] = env.d[key];
	}
	for(var name in found) {
		var n = name; for(var x=(len+1 - n.length); x>0; x--) { n += "&nbsp;"; }
		printRepl(n + ": " + format(found[name]));
	}
	if (len == 0) {
		printRepl("no "+label+" defined.");
	}
	printRepl("");
}

function processLine() {
	if (prompt.value == "\\\\") { partial = ""; return; }
	if (prompt.value == "\\e") {
		var editor = document.getElementById("editor");
		if (editor.style.display == "inline") {
			editor.style.display = "none";
			repl.style.width = "80%";
			saveBuffer();
		}
		else {
			editor.style.display = "inline";
			repl.style.width = "40%";
			loadBuffer();
			document.getElementById("textedit").focus();
		}
		return;
	}
	if (prompt.value == "\\r") {
		saveBuffer();
		prompt.value = document.getElementById("textedit").value;
	}
	if (prompt.value == "\\c") {
		scroll.innerHTML = "";
		panel.scrollTop = panel.scrollHeight;
		return;
	}
	if (prompt.value == "\\f") {
		printEnv(function(v) { return v.t >= 5 && v.t != 13; }, "functions");
		return;
	}
	if (prompt.value == "\\v") {
		printEnv(function(v) { return v.t < 5; }, "variables");
		return;
	}
	if (prompt.value == "kOS") { printRepl("one system/all devices"); return; }
	if (prompt.value.lastIndexOf("\\u") == 0) {
		var code = prompt.value.slice(2);
		var url = document.location + "?run=" + encodeURIComponent(code);
		printRepl("oK code url:");
		printRepl("<a href=\""+url+"\" target='_blank'>"+url+"</a>");
		return;
	}
	var showtime = false;
	if (prompt.value.lastIndexOf("\\t") == 0) {
		prompt.value = prompt.value.slice(2);
		showtime = true;
	}
	showtrace = false;
	if (prompt.value.lastIndexOf("\\x") == 0) {
		prompt.value = prompt.value.slice(2);
		showtrace = true;
	}
	var parsed = null;
	try { parsed = parse(" " + partial + "; " + prompt.value); }
	catch(error) {
		if (done() && (
			error.message == "parse error. '}' expected." ||
			error.message == "parse error. ')' expected." ||
			error.message == "parse error. ']' expected.")) {
			partial += ((partial!="")?";":"") + prompt.value;
			return;
		}
		else {
			printRepl("<font color='red'>"+error.message+"</font>");
			partial = "";
			return;
		}
	}
	partial = "";
	try {
		var starttime = new Date().getTime();
		printRepl(escapeHTML(format(run(parsed, env))));
		if (showtime) {
			var endtime = new Date().getTime();
			printRepl("completed in "+(endtime-starttime)+"ms.");
		}
	}
	catch(error) {
		printRepl(
			"<span style='color: red; cursor:pointer;' onclick='toggle(\"e"+(eid)+"\")'>"+error.message+
			"<div class='err' id='e"+(eid++)+"'><br>"+escapeHTML(error.stack)+"</div></span>"
		);
	}
}

function printReplBare(x) {
	scroll.innerHTML += x;
	panel.scrollTop = panel.scrollHeight;
}

function printRepl(x) {
	printReplBare("<br>");
	printReplBare(x);
}

function print(x, y) {
	// todo: use x to select a file descriptor
	try {
		var t = tojs(y);
		if (typeof t == "string") { printRepl(escapeHTML(t)); return y; }
		if (Array.isArray(t) && t.every(function(v) { return typeof v == "string"; })) {
			t.map(function(v) { printRepl(escapeHTML(v)); }); return y;
		}
	}
	catch(e) {}
	throw new Error("0: can only display strings or lists of strings.");
}

function readAjax(x) {
	var url = tojs(x);
	if (typeof url != 'string') { throw new Error("string expected."); }
	var request = new XMLHttpRequest();
	request.open('GET', url, false);
	request.send(null);
	return [request.status, request.responseText];
}

function readText(x) { return tok(readAjax(x)); }

function readJSON(x) {
	var t = readAjax(x);
	t[1] = JSON.parse(t[1]);
	return tok(t);
}

var urlstring = location.search.match(/run=([a-zA-Z0-9-_.!~*'()%]+)/);
if (urlstring) {
	var code = decodeURIComponent(urlstring[1]).trim();
	printRepl("from url ");
	prompt.value = code;
	processInput({keyCode:13});
}

 </script>

</body>
</html>